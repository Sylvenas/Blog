---
title: "应用函子 - Applicative"
author: [Sylvenas]
categories: "Monad"
img: './img/2015-06-07.jpeg'
---

### 加法运算
现在让我们回想一下第一章中我们反复介绍的`Functor`的核心思想，就是通过`map`，把一个函数应用到包裹的值上：`Box(1).map(x => x+1)`,通常我们都是把一个值装进Box中，然后不断的通过`map`变化其中的值，别忘了在函数式的思维中，[函数是一等公民]()，我们如果先把一个函数包装进了Box中，然后在需要的时候在应用这个函数，举个例子说明：

``` js
const addOne = x => x + 1

Box(addOne) // => Box(x => x+1)
```
现在我们得到了一个包裹着函数的Box，可是我们怎么使用这个函数呢？毕竟平常的Functor map方法都是接收一个函数！

不如继续回到函数`addOne`上，我们需要一个数字，传递给`addOne`,对吧！所以思路继续转换一下，我们怎么传递一个数据进去应用这个`addOne`函数呢，答案非常简单，继续传递一个被包裹的值，然后map这个函数不就可以啦!看代码：

``` js
const Box = x => ({
    map: f => Box(f(x)),
    flod: f => f(x),
    apply: o => o.map(x),
    [inspect]: () => `Box(${x})`
})
Box(addOne).apply(Box(2)) // => Box(3)
```
看看Box神奇的新方法，首先被包裹的值是一个函数x，然后我们继续传递另一个`Box(2)`进去，不就可以使用`Box(2)`上的map方法调用`addOne`函数了吗！

> 这和`柯里化`,`偏应用`的思路非常类似，先传递部分参数(函数完全可以当成普通的参数传递)，然后继续传递部分参数，最后进行求值操作。

现在重新审视一下我们`Box(addOne)`,`Box(1)`,那么这个问题实际上可以归结为：把一个 `functor` 应用到另一个上functor上，而这也就是`applicative functor`(应用函子)最擅长的操作了,看一下示意图来描述应用函子的操作流程

![applicative functor](https://p1.music.126.net/kfldU46LvUhUaY_QjP6LHw==/109951164712439705.png)

所以根据上面的讲解和实例我们可以得出一个结论：先把一个值`x`装进`Box`，然后`map`一个函数`f`和把函数`f`装进`Box`，然后`ap`一个已经已经装进`Box`的`x`，是完全等价的！
``` js
F(x).map(f) == F(f).ap(F(x))

Box(2).map(addOne) == Box(addOne).apply(Box(2))  // => Box(3)
```
> 根据[规范](https://github.com/fantasyland/fantasy-land#applicative),apply 方法后面我们会简写为`ap`!

> applicative functor 也是函数式编程中一大堆“故弄玄虚”的概念中唯一的比较“名副其实”的了，想想`Functor(mappable)`,`Semigroup(concatible)`

### 柯里化与应用函子
继续往前走一步，思考一下，如果现在有两个被包裹的值，怎么把一个函数应用上去呢？举个例子：
``` js
const add = x => y => x + y

add(Box(1), Box(2))
```
现在我们没办法直接把`Box(1)`和`Box(2)`相加，他们都在盒子里;可是我们的需求不就是把`Box(1)`,`Box(2)`,`add` 三者互相应用一下吗？不管怎么说，我们先把`add`函数包装进Box中,然后得到了一个应用函子`Box(add)`,不就可以继续ap了吗

``` js
Box(add).ap(Box(1))  // => Box(y => x +y) (得到另一个应用函子)
Box(add).ap(Box(1)).ap(Box(2))  // => Box(3) (得到最终的结果)
```
上面的例子，我们可以得出一个结论，一个柯里化的函数，有几个参数，我们就可以ap几次！
再次套用一下上面的公式：
``` js
F(x).map(f) == F(f).ap(F(x))

Box(1).map(add) == Box(add).ap(Box(1))

Box(1).map(add).ap(Box(2)) == Box(add).ap(Box(1)).ap(Box(2))
```

### 应用函子的实际应用
表单校验是我们日常开发中非常常见的一个模块，举个具体的例子，假如我们有一个用户注册的表单，我们需要校验用户名，密码，与邮箱三个字段，常见的代码如下：
``` js
const checkUserInfo = user => {
    const { name, pw, phone } = user
    const errInfo = []
    if (/^(0|[1-9][0-9]*)$/.test(name)) {
        errInfo.push('用户名不能是数字')
    }
    if (pw.length >= 6) {
        errInfo.push('密码长度必须大于6位')
    }

    if (/^1[3|4|5|7|8][0-9]{9}$/.test(phone)) {
        errInfo.push('手机号码不正确')
    }

    if (errInfo.length) {
        return errInfo 
    }
    return 'success'
}

const userInfo = {
    name: '12',
    pw: '',
    phone: '15381048021'
}

const checkRes = checkUserInfo(userInfo)
console.log(checkRes)  // => { res: false, errInfo: [ '用户名不能是数字', '手机号码不正确' ] }
```
这个代码自然没有问题，但是，假如我们要继续添加需要校验的字段的话，`checkUserInfo`函数毫无疑问会越来越大，并且如果我们要修改某一个字段的校验规则的话，整个`checkUserInfo`函数可能会收到影响，我们需要增加的单元测试工作要更多了，现在按照函数式的思维(函数组合)来拆分一下`checkUserInfo`函数：

``` js
const checkName = name => {
   return /^(0|[1-9][0-9]*)$/.test(name)
}

const checkPW = pw => {
    return pw.length >= 6
}

const checkPhone = phone => {
    return /^1[3|4|5|7|8][0-9]{9}$/.test(phone)
}
```
现在我们拆分成对三个字段分别校验的函数`checkName`,`checkPW`,`checkPhone`,每个函数返回的结果要么是`true`，要么是`false`，这个和我们第一章介绍的`Either`(向左 or 向右)何其相似,只不过我们现在面临的情况是要么校验成功，要么检验失败，所以我们完全可以仿照`Either functor` 写`Validation`,它也拥有两个分支：`Success / Failure`
``` js
const Success = x => ({
    x,
    map: f => Success(f(x)),
    fold: (f, g) => g(x),
    ap: o => o.isFailure ? o : o.map(x),
    isSuccess: true,
    isFailure: false,
    [inspect]: () => `Success(${x})`
})

const Failure = x => ({
    x,
    map: f => Failure(x),
    ap: o => o.isFailure ? Failure(x.concat(o.x)) : Failure(x),
    fold: (f, g) => f(x),
    isSuccess: false,
    isFailure: true,
    [inspect]: () => `Failure(${x})`
})
```
相对比与`Either`，新增了`x`属性和`ap`方法，其他的属性完全类似，就不做解释了；新增`x`属性的原因在于需要记录表单校验的错误信息，这个很好理解；

我们仔细看一下新增的`ap`方法，先看`Sucsess`分支的ap：`o => o.isFailure ? o : o.map(x)`,毫无疑问`ap`方法接收另一个`functor`，如果另一个`functor`是`Failure`的实例，则不需要`Success`处理直接返回，如果不是`Failure`，则和平常`applicative functor`一样，对`o`作为主题进行map;

在看`Failure`分支上的ap：`o => o.isFailure ? Failure(x.concat(o.x)) : Failure(x)`,如果是`Failure`的实例，则进行一个类似于`semigroup`的`concat`操作，实际上就是为了累加错误信息，而如果不是`Failure`的实例则直接返回原本已经记录的错误信息。

做好了前期的准备工作，我们就可以大刀阔斧的修改`checkUserInfo`函数了：
``` js
const success = () => 'success';

function checkUserInfo(user) {
    const { name, pw, phone } = user
    // 3 是因为我们正调用 `ap` 3 次。
    let returnSuccess = R.curryN(3, success);

    return Success(returnSuccess)
        .ap(checkName(name))
        .ap(checkPW(pw))
        .ap(checkPhone(phone))
}

const checkRes = checkUserInfo(userInfo)
console.log(checkRes) // => Failure(用户名不能是数字,手机号码不正确)
```
上面代码中对`success`函数执行`curryN(3, success)`的操作，就是为了后面可以[连续的ap三次]()

> 此处需要指出的是`applicative functor`更擅长的是处理并行问题的能力，`checkName`，`checkPW`，`checkPhone`函数都是同步函数，假如说这三个函数都是异步的，那么实际上这三个请求‘几乎会同时’发送出去，别着急，后面的章节我们会讨论异步的世界，现在只要把理论和概念理解清楚就OK！

### applicative的定理

#### 同一律（identity）
完全类似于functor的同一律完全类似，先把id函数包装进Applicative functor中，然后`apply`一个`Box(1)`和`Box(1).map(id)`的结果是一样
``` js
const id = x => x

A(id).ap(A(x)) == A(x).map(id) == A(x)

Box(id).ap(Box(1)) == Box(1).map(id) == Box(1)
```

#### 同态（homomorphism）
``` js
A(f).ap(A(x)) == A(x).map(f) == A(f(x))

Box(addOne).ap(Box(1)) == Box(1).map(addOne) == Box(addOne(1)) == Box(2)
```

#### 互换（interchange）
``` js
A(f).ap(A(x)) == A(f=>f(x)).ap(Box(f))

Box(addOne).ap(Box(1)) == Box(f => f(1)).ap(Box(addOne)) == Box(2)
```

#### applicative和functor的区别和联系
根据applicative的同一律和同态，两条特性，我们可以得出一个结论，假如一个盒子(Box),实现了`ap`方法，那么我们一定可以利用`ap`方法推导出一个`map`方法，如果拥有了`map`方法，那它就是一个`functor`,所以我们也可以认为`applicative`是`functor`的拓展，比`functor`更强大。

那么强大在何处呢? `functor`只能映射一个接收单个参数的函数(i.e., `x=>y`),如果我们想把接收多个参数的函数(i.e., `x => y => z`)应用到多个值上，则是applicative的舞台了，
想想`checkUserInfo`的例子。

上面是实际应用中的对比，从抽象的数学层面来对比：
- functor: 应用一个函数到包裹的值:`Box(1).map(x => x+1)`.
- applicative: 应用一个包裹的函数到包裹的值:`Box(x => x+1).ap(Box(1))`.

![applicative vs functor](https://p1.music.126.net/qnIolKU9yLB9tH7onLbj7w==/109951164719087429.png)

参考资料与引用文章：   
[1]: [functor-applicative-and-why?](https://medium.com/axiomzenteam/functor-applicative-and-why-8a08f1048d3d)   
[2]: [applicative and list](https://stackoverflow.com/questions/46752031/what-is-my-applicative-functor-not-working-with-ramdas-ap)   
[3]: [Monad in Pictures](http://jiyinyiyong.github.io/monads-in-pictures/)      
[4]:《JavaScript函数式编程》   
