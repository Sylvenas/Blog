---
title: "俄罗斯套娃娃 - Monad"
author: [Sylvenas]
categories: "Monad"
img: './img/2015-02-10.jpg'
---

前面三章我们分别学习了`Functor`和`Applicative`的概念和实际应用，并列举了几个具体的例子，来说明了Functor和`Applicative`的实际用途，比如：使用`Either`来处理空值和更优雅的`try-catch`;使用`Validation`来做高度灵活高度可拓展的表单校验;同时我们应该已经牢牢掌握了`functor`的核心`map`，应用一个函数到包裹的值，`applicative`的核心`ap`，应用一个包裹的函数到一个包裹的值。

别忘了我们之前遗留的几个问题：

* 如何解决嵌套的`try-catch`
* 异步函数的组合
* `chain`函数又是什么

我们一个一个的来解决,先从第一个嵌套的`try-catch`开始入手：

### Array.prototype.flatMap

`Javascript Array` 的map方法，相信我们每个人都非常的熟悉，并且几乎在每天的编程中都可能会用到，但`Array`的原型链上的另一个方法`Array.prototype.flatMap`可能很多人没怎么用过，从字面意思上理解就是扁平化的`map`，实际作用上也确实是的，我们看一个和`map`做对比的使用案例：

``` js
const arr = [1, 2, 3, 4]

arr.map(x => [x * 2])  // => [[2], [4], [6], [8]]

arr1.flatMap(x => [x * 2])  // => [2, 4, 6, 8]
```
`flatMap`相对于`map`的区别是：

- `map`是把函数执行的结果，放在一起然后装进一个Box中；
- `flatMap`的结果是把**函数执行的结果分别去掉一层“包装”**，然后放在一起装进一个Box中

所以`flatMap`相当于是先`map`(映射)然后`flat`(拍平), 仅仅是多了一个“去包装”的操作！

下图这个流程完美的展现了`flatMap`的工作方式：

![flatMap](https://p1.music.126.net/heup-JwK7nvaKfasxckrig==/109951164726073715.gif)

### 嵌套的try-catch
上面介绍了Array的一种先`map`在`flat`的方法，Array也是我们`Box`理念的一个具体实现案例，那其他的Box呢？`Maybe`，`Either`又是如何实现的呢？我们先从一个更简单的函数组合的案例出发吧，现在我们需要编写一个获取用户地址的街道名称函数：

``` js
const address = user => user.address
const street = address => address.street

const app = compose(street, address)

const user = {
    address: {
        street: '长安街'
    }
}

const res = app(user) // => 长安街
```

函数组合的理论也非常简单，只要上一个函数的返回值类型可以作为下一个函数的入参就可以放心大胆的进行组合了。

但是别忘了，我们的`user`对象上面`address`属性可能为`null/undefined`,上面的这段代码如果我们不做任何防范，那么`TypeError`的错误是不可避免的！这个问题不用担心，我们之前已经完全准备好了用来处理`null/undefined`的`Maybe functor`。现在我们`Maybe`来包装一下上面代码：

``` js
const address = user =>  Maybe(user).map(u => u.address)
const street = address => Maybe(address).map(a => a.street)

const app = user =>
    address(user)                   // Maybe(address)
        .map(street)                // Maybe(Maybe(street))
```
看一下上面的代码，`address(user)`函数的返回值是`Maybe(address)`,然后我们继续map,把`address`传递给了`street`函数，别忘了`map`方法(`map: f => Just(f(x))`)会把函数计算的结果重新包装进Box中，所以我们最终得到的结果是一个`Maybe(Maybe(street))`。

这个时候如果我们想获取最终的street的结果，不得不在`map`之后先用`getOrElse`拆包第一层，然后再用`getOrElse`拆包第二层，最后得到最终的结果。
``` js
const app = user =>
    address(user)          // Maybe(address)
        .map(street)       // Maybe(Maybe(street))
        .getOrElse()       // Maybe(street)
        .getOrElse()       // street
```

这简直是代码版本的俄罗斯套娃娃：

![russian-dolls](https://p1.music.126.net/M5xz6W-YU5gxERxRhLscRw==/109951164726066989.gif)

毫无疑问，我们有几次包装，就需要几次“拆包”操作，这样做逻辑上自然是没有什么问题。但是这岂不是和前端常见的[回调地狱]()问题很类似，这样的代码写下去实在是太难维护和看懂了，我们总不能写一行就要数数有几层包装吧！

回头想想出现两层包装的原因是出在`map`方法上，`map`会把函数计算的结果重新包装进Box中，而这一层包装对我们来说有点赘余，我们之后马上进行了拆箱操作，这非常类似于`Array flatmap`的理念。

**所以我只需要一个方法(flatMap/chain)帮我们直接执行函数不做其他的任何操作，因为函数的返回值已经是被包装好了**

``` js
const Just = x => ({
  chain: f => f(x),
});

const Nothing = x => ({
  chain: f => Nothing(x),
});

const app = user =>
    address(user)                         // Maybe(address)
        .chain(street)                    // Maybe(street)
        .flod(() => 'no street',x => x)    // street
```

此时，我们可以明显的对比出来`map`和`chain`的不同点：`map`方法接收一个仅仅变换容器内值的函数，所以需要用Box重新包装；但是`chain`接收一个返回Box类型的函数仅此而已。

`map`和`chain`的相同点却是非常明显的：都是返回一个Box的实例，方便后面继续链式的调用。

> `chain`方法和`flod`方式非常相像，这我得承认他们确实很类似，但是他们的使用场景却完全不同！`flod`的通途是把一个值从Box中解放出来；`chain`的用途是把一个返回Box的函数应用到一个Box上,这样后面可以继续保持链式的调用。

既然我们可以解决了嵌套的`Maybe`问题，那么嵌套的try-catch，自然用同样的理论也可以迎刃而解了：

``` js
const Right = x => ({
  chain: f => f(x),
});

const Left = x => ({
  chain: f => Left(x),
});

const jsonFormat = str =>
    tryCatch(() => JSON.parse(str))
        .map(x => x.ext)

const extFormat = ext =>
    tryCatch(() => JSON.parse(ext))

const app = str =>
    jsonFormat(str)
        .chain(extFormat)
        .flod(() => 'no ext', x => x)

const str = '{ "ext": "" }'

const res = app(str) // => 'no ext'
```

### 异步与Monad

到目前为止，我们所讨论的问题都同步的问题，但是在Javascript的世界中90%的代码都是异步，可以说异步才是JavaScript世界的主流，谁能更优雅的解决异步的问题，谁就是JavaScript中的大明星，从刚开始的`callback`，到`Promise`，再到`async await`，那么在函数式编程中异步又该如何解决呢，从最常见的`http`请求作为引入的事例吧：
``` js
const httpGetUser = (id) => Promise.resolve({ name: 'James', id })

const httpGetMovies = (user) =>
    Promise.resolve(user.id > 1 ? ['加勒比海盗', '霍比特人', '蜘蛛侠'] : ['教父', '小丑'])

const app = (id) => httpGetUser(id)
    .then(httpGetMovies)
    .then(console.log, console.error)

const res = app(3)  // => ['加勒比海盗', '霍比特人', '蜘蛛侠']
```
`httpGetUser`函数返回用户相关的信息，`httpGetMovies`函数根据用户`id`，返回电影列表类似的需求在我们的业务场景中也是非常常见的,现在我们简单的抽象一下上面的代码：
``` js
httpGetUser :: id -> Promise(user)
httpGetMovies :: user -> Promise(movies)
app :: id -> 
    httpGetUser(id)
        .then(httpGetMovies)
        .then(console.log, console.error)
```
然后我们对比一下上一节中的获取街道名称的例子:
``` js
address :: user ->  Maybe(address)
street :: address -> Maybe(street)

app :: user ->
    address(user)                         // Maybe(address)
        .chain(street)                    // Maybe(street)
        .flod(() => 'no street',x => x)    // street
```

❗️️️❗️️️❗️️️ 这两个例子是何其的类似，两个函数的定义和两个`app`的调用方式，除了一个是`Maybe`一个是`Promise`，一个`chain`一个是`flod`。

Promise把我们从异步回调地狱中解放出来，而添加`chain`方法的`Maybe`，可以让我们从嵌套的`Maybe`中解脱出来。为何会这么的类似！

其实这是`Maybe`，`Promise`都是Monad(单子)的概念的拓展和具体实现！而`monad` 这个名字多么的让人难以理解，如果你去google一下`monad`，有无数篇在讲解`monad`,其中最经典的一个解释为：

> “A monad is just a monoid in the category of endofunctors. What’s the problem?”

![monad](https://p1.music.126.net/dUKuPfnrnZ0zt2zRfC8AOA==/109951164726072211.png)

好吧其实上面这句话的出处是[brief-incomplete-and-mostly-wrong](http://james-iry.blogspot.com/2009/05/brief-incomplete-and-mostly-wrong.html),完全是为何吐槽Haskell而说的，理论上没有错，但是却感觉是一句无用的废话。

而Monad的准确定义是：

> All told, a monad in X is just a monoid in the category of endofunctors of X, with product × replaced by composition of endofunctors and unit set by the identity endofunctor.

所以上面这个定义你看懂了吗?(~~别打我~~)看不懂，真的没有关系，因为那是为专业的数学学生而准备的，我们只要掌握monad在实际代码中可以理解为`chainable`的对象即可

### 函数组合与monad

在常规的函数组合中只要前一个函数的返回值是下一个函数的入参就可以，进行组合：
``` js
const compose = (...fns) => x => fns.reduceRight((f, g) => g(f), x);
```
但是
``` js
const address = user =>  Maybe(user).map(u => u.address)
const street = address => Maybe(address).map(a => a.street)

const app = compose(street, address) // 可以这样组合吗？ No!
```

我们没办法直接把`address`的返回值直接传递给`street`函数，因为`address`函数的返回值是一个`Maybe(address)`，函数`street`的入参是`address`，所以我们要使用`chain`方法把`address从Maybe(address)`中提取出来，然后传递给`street`函数，所以`monad`版本`compose`就应运而生了：
``` js
const composeM = method => (...fns) => (fns.reduce((f, g) => x => g(x)[method](f)));

const composeChain = composeM('chain');

const app = composeChain(street, address)

const res = app(user).getOrElse('no street')
```

这样的定理也完全适用于Promise的组合：
``` js
const composeThen = composeM('then');

const app = composeThen(httpGetMovies, httpGetUser)

const res = app(3).then(console.log, console.error) // => ['加勒比海盗', '霍比特人', '蜘蛛侠']
```

### monad 定律

#### 结合律
``` js
m.chain(f).chain(g) === m.chain(x => f(x).chain(g))
```
这个定律我们在`composeChain`，`composeThen`的例子中已经证明过了

#### identity
``` js
M(x).chain(f) === f(a) // Left identity
M(x).chain(M) === M(x) // Right identity
```

这个实在是太简单的，而现在同时满足结合律和`identity`定律的集合又可以被称为**幺半群**，所以这也就解释了

> “A monad is just a monoid in the category of endofunctors. What’s the problem?”

但是这真的是个巧合，仅仅是个调侃罢了，幺半群也不是Monad的主要使用方向。

### Monad与Applicative

Monad更擅长处理的是一种拥有`Context`的场景，我们上面的`httpGetUser`与`httpGetMovies`的例子中，`httpGetMovies`函数必须等到`httpGetUser`函数中的异步执行完成才能开始调用，这是一种**纵向(串行)**的链路；

而**Applicative更擅长的是处理一种横向(并行)的链路**，比如上一章介绍的表单校验的例子，每个字段的校验之间完全没有什么关联关系。


### 总结
- `Functor`是一种实现`map`方法的数据类型
- `Applicative`是一种实现了`apply`方法的数据类型
- `Monad`是一种实现了`chain`或`flatmap`方法的数据类型.

那么`Functor`、`Applicative`和`Monad`三个区别是什么？

![functor-applicative-monad](https://p1.music.126.net/bDmdHmGZ635HmpgBPy-tlw==/109951164726068415.png)

- `Functor`: 应用一个函数到包裹的值，使用`map`.
- `Applicative`: 应用一个包裹的函数到包裹的值,使用`ap`
- `Monad`: 应用一个返回包裹值的函数到一个包裹的值，使用`chain`.




参考资料与引用文章：   
[1]: [your easy guide to monads applicatives functors](https://medium.com/@lettier/your-easy-guide-to-monads-applicatives-functors-862048d61610)   
[2]: [functor-monad](https://www.jdon.com/idea/functor-monad.html)   
[3]:《JavaScript函数式编程》   
[4]: [写给程序员的范畴论](https://bartoszmilewski.com/2014/10/28/category-theory-for-programmers-the-preface/)
