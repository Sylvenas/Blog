---
title: "What is a Closure?"
author: [Sylvenas]
categories: "functional"
img: './img/2017-11-25.jpeg'
---
简而言之，**闭包**是函数和声明该函数的词法环境(lexical environment)的组合。换句话说，闭包就是允许一个内部函数有权限访问外部函数作用域中的变量，即使外部函数已执行完毕。在JavaScript中，在任意一个函数被创建的时候，都会形成闭包。

要使用闭包，只需要简单的把一个函数定义在另一个函数内部，并将它暴露出来。要暴露一个函数，可以将它返回或者传递给其他函数。

### 

### Using Closures (Examples)
* 创建私有变量
在JavaScript中，闭包是用来实现数据私有的原生机制。当你使用闭包来实现数据私有时，被封装的变量只能在闭包容器函数(外部函数)作用域中使用。你不能在外部作用域中访问这些被包装的变量，除非你使用对象的**特权方法**。
任何定义在闭包作用域病暴露到外部的函数，都属于特权方法。例如：
``` js
const getSecret = function (data) {
    let secret = data;
    return {
        get: function () {
            return secret;
        }
    }
}

const obj = getSecret('hello world');

obj.get();   // hello world
```
在上面的例子里，`get()`方法定义在`getSecret()`作用域下，这让它可以访问到任何`getSecret`方法内的变量，于是`get()`就是一个被授权的方法。在这个例子里，它可以访问参数`secret`。

上面的例子还有一个常见的陷阱，在上面例子的基础上追加一些代码:
``` js
obj.addData = function (newData){
    return secret += newData
}
obj.addData('nihao');
```
这个时候，很多人会误以为,`obj.addData('nihao')`表达式的返回值会是`'hello world nihao'`,但是实际上，这个表达式根本不能正确的执行下去，反而会报错(`secret is not defined`),有些人会很奇怪为何啊，我不是明明创建闭包的时候，已经添加了对`secret`的引用了吗？

事实并非如此，`get`函数在创建的时候，添加了对`secret`变量的引用(或者说对自由变量的捕获是在闭包创建的时候)，而`addData`函数在创建的时候，完全没有添加对`secret`的引用。仔细考虑一下，对不对！

闭包还有一个常见的陷阱，看个简单的例子：
``` js
function showObject(obj) { 
    return function () { 
        return obj
    }
}

var o = { a: 1 };
var showO = showObject(o);
showO()  // {a:1}
```
上面的代码看上去没有任何问题，对不对？考虑到我们添加如下代码：
``` js
o.a = 6;
showO()  // {a:6}
```
这个时候，再次调用`showO()`函数的时候，返回值竟然发生了变化，上面还明明在说闭包可以创建私有变量的啊！

这是因为`o`的引用同时存在与闭包的内部和外部，它的变化可以跨越看似私有的界限。这很容易导致混乱，所以通常情况下我们应当最大限度的减少捕获全局作用域的变量，来作为闭包的私有变量。

* 在函数式编程中，闭包经常用于偏应用和柯里化
为了说明这个，我们先定义一些概念：

**函数应用**：将参数传给一个函数，并获得函数的返回值的过程。

**偏应用**：先传递给某个函数一部分的参数，然后返回一个新函数，该函数等待接收剩余的全部参数。
 
偏应用就是通过闭包作用于来进行提前赋予参数。关于偏应用和柯里化可以查看 [partial application and curry](blog/2017/11/23/Curry-and-PartialApplication.html)
