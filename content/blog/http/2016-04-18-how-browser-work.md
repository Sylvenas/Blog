---
title: "how browser work"
author: [Sylvenas]
categories: "browser"
img: './img/2016-04-18.jpeg'
---

关于浏览器的工作原理，一直存有好奇却又无从下手的状态，最近看到了一篇绝对棒的文章（[原文链接](https://www.html5rocks.com/en/tutorials/internals/howbrowserswork)），具体讲解了主流浏览器的工作原理，部分摘抄如下：

### 简介
网络浏览器很可能是使用最广的软件。在这篇入门文章中，我将会介绍它们的幕后工作原理。我们会了解到，从您在地址栏输入`google.com`直到您在浏览器屏幕上看到Google首页的整个过程中都发生了些什么。

### 浏览器的主要功能
浏览器的主要功能就是向服务器发出请求，在浏览器窗口中展示您选择的网络资源。这里所说的资源一般是指`HTML`文档，也可以是`PDF`、`图片`或其他的类型。资源的位置由用户使用`URI`（统一资源标示符）指定。

浏览器解析并显示`HTML`文件的方式是在`HTML`和`CSS`规范中指定的。这些规范由网络标准化组织`W3C`（万维网联盟）进行维护。
多年以来，各浏览器都`没有完全`遵从这些规范，同时还在开发自己独有的扩展程序，这给网络开发人员带来了严重的兼容性问题。如今，大多数的浏览器都是或多或少地遵从规范。

浏览器的用户界面有很多彼此相同的元素，其中包括：

* 用来输入`URI`的地址栏
* 前进和后退按钮
* 书签设置选项
* 用于刷新和停止加载当前文档的刷新和停止按钮
* 用于返回主页的主页按钮
奇怪的是，浏览器的用户界面并没有任何正式的规范，这是多年来的最佳实践自然发展以及彼此之间相互模仿的结果。HTML5也没有定义浏览器必须具有的用户界面元素，但列出了一些通用的元素，例如地址栏、状态栏和工具栏等。当然，各浏览器也可以有自己独特的功能，比如 Firefox 的下载管理器。

### 浏览器的高层结构
浏览器的主要组件为 (1.1)：

* 用户界面 - 包括地址栏、前进/后退按钮、书签菜单等。除了浏览器主窗口显示的您请求的页面外，其他显示的各个部分都属于用户界面。
* 浏览器引擎 - 在用户界面和呈现引擎之间传送指令。
* 呈现引擎 - 负责显示请求的内容。如果请求的内容是 HTML，它就负责解析 HTML 和 CSS 内容，并将解析后的内容显示在屏幕上。
* 网络 - 用于网络调用，比如 HTTP 请求。其接口与平台无关，并为所有平台提供底层实现。
* 用户界面后端 - 用于绘制基本的窗口小部件，比如组合框和窗口。其公开了与平台无关的通用接口，而在底层使用操作系统的用户界面方法。
* JavaScript解释器 - 用于解析和执行 JavaScript 代码。
* 数据存储 - 这是持久层。浏览器需要在硬盘上保存各种数据，例如 Cookie。新的 HTML 规范 (HTML5) 定义了“网络数据库”，这是一个完整（但是轻便）的浏览器内数据库。

<div style="text-align:center;margin-top:20px" align="center">
  <img style="height:200px;" src="../images/browser-layers.png" />
</div>  

值得注意的是，和大多数浏览器不同，Chrome 浏览器的每个标签页都分别对应一个呈现引擎实例。每个标签页都是一个独立的进程。

### 呈现引擎
呈现引擎的作用嘛...当然就是"呈现"了，也就是在浏览器的屏幕上显示请求的内容。

默认情况下，呈现引擎可显示HTML和XML文档与图片。通过插件（或浏览器扩展程序），还可以显示其他类型的内容；例如，使用 PDF 查看器插件就能显示 PDF 文档。但是在本章中，我们将集中介绍其主要用途：显示使用 CSS 格式化的 HTML 内容和图片。

本文所讨论的浏览器（Firefox、Chrome 浏览器和 Safari）是基于两种呈现引擎构建的。Firefox 使用的是 Gecko，这是 Mozilla 公司“自制”的呈现引擎。而 Safari 和 Chrome 浏览器使用的都是 WebKit。

WebKit 是一种开放源代码呈现引擎，起初用于 Linux 平台，随后由 Apple 公司进行修改，从而支持苹果机和 Windows。有关详情，请参阅 webkit.org。

#### 主流程
呈现引擎一开始会从网络层获取请求文档的内容，内容的大小一般限制在 8000 个块以内。

然后进行如下所示的基本流程：

<div style="text-align:center;margin-top:20px" align="center">
  <img style="height:200px;" src="../images/browser-flow.png" />
</div>

呈现引擎将开始解析 HTML 文档，并将各标记逐个转化成 **内容树** 上的 DOM 节点。同时也会解析外部 CSS 文件以及样式元素中的样式数据。HTML 中这些带有视觉指令的样式信息将用于创建另一个树结构：**呈现树**。

呈现树包含多个带有视觉属性（如颜色和尺寸）的矩形。这些矩形的排列顺序就是它们将在屏幕上显示的顺序。

呈现树构建完毕之后，进入 **布局** 处理阶段，也就是为每个节点分配一个应出现在屏幕上的确切坐标。下一个阶段是 **绘制** - 呈现引擎会遍历呈现树，由用户界面后端层将每个节点绘制出来。

需要着重指出的是，这是一个渐进的过程。为达到更好的用户体验，呈现引擎会力求尽快将内容显示在屏幕上。它不必等到整个 HTML 文档解析完毕之后，就会开始构建呈现树和设置布局。在不断接收和处理来自网络的其余内容的同时，呈现引擎会将部分内容解析并显示出来。
下面是WebKit内核浏览器的主流程示例：
<div style="text-align:center;margin-top:20px" align="center">
  <img style="height:200px;" src="../images/browser-webkitflow.png" />
</div>

#### 解析的基本流程
解析文档是指将文档转化成为有意义的结构，也就是可让代码理解和使用的结构。

解析得到的结果通常是代表了文档结构的节点树，它称作解析树或者语法树。

解析的过程可以分成两个子过程：`词法分析`和`语法分析`。

`词法分析`是将输入内容分割成大量标记的过程。标记是语言中的词汇，即构成内容的单位。在人类语言中，它相当于语言字典中的单词。

`语法分析`是应用语言的语法规则的过程。
解析器通常将解析工作分给以下两个组件来处理：`词法分析器`（有时也称为标记生成器），负责将输入内容分解成一个个有效标记；而`解析器`负责根据语言的语法规则分析文档的结构，从而构建`解析树`。词法分析器知道如何将无关的字符（比如空格和换行符）分离出来。
<div style="text-align:center;margin-top:20px" align="center">
  <img style="height:200px;" src="../images/browser-lexical.png" />
</div>

解析是一个迭代的过程。通常，解析器会向词法分析器请求一个新标记，并尝试将其与某条语法规则进行匹配。如果发现了匹配规则，解析器会将一个对应于该标记的节点添加到解析树中，然后继续请求下一个标记。

如果没有规则可以匹配，`解析器`就会将标记存储到内部，并继续请求标记，直至找到可与所有内部存储的标记匹配的规则。如果找不到任何匹配规则，解析器就会引发一个异常。这意味着文档无效，包含语法错误。

很多时候，`解析树`还不是最终产品。解析通常是在`翻译`过程中使用的，而`翻译`是指将输入文档转换成另一种格式。编译就是这样一个例子。编译器可将源代码编译成机器代码，具体过程是`首先将源代码解析成解析树，然后将解析树翻译成机器代码文档`。
<div style="text-align:center;margin-top:20px" align="center">
  <img style="height:200px;" src="../images/browser-translate.png" />
</div>

#### 处理脚本和样式表的顺序
##### 脚本
网络的模型是同步的。网页作者希望解析器遇到`<script>`标记时立即解析并执行脚本。文档的解析将停止，直到脚本执行完毕。如果脚本是外部的，那么解析过程会停止，直到从网络同步抓取资源完成后再继续。此模型已经使用了多年，也在 HTML4 和 HTML5 规范中进行了指定。作者也可以将脚本标注为`defer`，这样它就不会停止文档解析，而是等到解析结束才执行。HTML5 新增了`async`属性可将脚本标记为异步，以便由其他线程解析和执行。

当浏览器碰到`scrip` 脚本的时候：     
* `<script src="script.js"></script>`
没有`defer`或`async`，浏览器会立即加载并执行指定的脚本，`立即`指的是在渲染该`script`标签之下的文档元素之前，也就是说不等待后续载入的文档元素，读到就加载并执行。

* `<script async src="script.js"></script>`
有`async`，加载和渲染后续文档元素的过程将和`script.js`的加载与执行并行进行(异步)，`async`的执行，并不会按着`script`在页面中的顺序来执行，而是谁先加载完谁执行。     

* `<script defer src="myscript.js"></script>`   
如果`script`标签设置了该属性，则浏览器会异步的下载该文件并且不会影响到后续DOM的渲染；如果有多个设置了`defer`的script标签存在，则会按照顺序执行所有的script；`defer`脚本会在文档渲染完毕后，`DOMContentLoaded`事件调用前执行。、

<div style="text-align:center;margin-top:20px" align="center">
  <img style="height:200px;" src="../images/script-async.jpeg" />
</div>

蓝色线代表网络读取，红色线代表执行时间，这俩都是针对脚本的；绿色线代表 HTML 解析。
##### 预解析
WebKit和Firefox都进行了这项优化。在执行脚本时，其他线程会解析文档的其余部分，找出并加载需要通过网络加载的其他资源。通过这种方式，资源可以在并行连接上加载，从而提高总体速度。请注意，预解析器不会修改DOM树，而是将这项工作交由主解析器处理；预解析器只会解析外部资源（例如外部脚本、样式表和图片）的引用。

#####样式表
另一方面，样式表有着不同的模型。理论上来说，应用样式表不会更改DOM树，因此似乎没有必要等待样式表并停止文档解析。但这涉及到一个问题，就是脚本在文档解析阶段会请求样式信息。如果当时还没有加载和解析样式，脚本就会获得错误的回复，这样显然会产生很多问题。这看上去是一个非典型案例，但事实上非常普遍。Firefox 在样式表加载和解析的过程中，会禁止所有脚本。而对于WebKit而言，仅当脚本尝试访问的样式属性可能受尚未加载的样式表影响时，它才会禁止该脚本。

### 构建呈现树
在 DOM 树构建的同时，浏览器还会构建另一个树结构：呈现树。这是由可视化元素按照其显示顺序而组成的树，也是文档的可视化表示。它的作用是让您按照正确的顺序绘制内容。

Firefox 将呈现树中的元素称为“框架”。WebKit 使用的术语是呈现器或呈现对象。
呈现器知道如何布局并将自身及其子元素绘制出来。

#### 呈现树和DOM树的关系
呈现器是和 DOM 元素相对应的，但并非一一对应。非可视化的 DOM 元素不会插入呈现树中，例如“head”元素。如果元素的 display 属性值为“none”，那么也不会显示在呈现树中（但是 visibility 属性值为“hidden”的元素仍会显示）。
有一些 DOM 元素对应多个可视化对象。它们往往是具有复杂结构的元素，无法用单一的矩形来描述。例如，“select”元素有 3 个呈现器：一个用于显示区域，一个用于下拉列表框，还有一个用于按钮。如果由于宽度不够，文本无法在一行中显示而分为多行，那么新的行也会作为新的呈现器而添加。
另一个关于多呈现器的例子是格式无效的 HTML。根据 CSS 规范，inline 元素只能包含 block 元素或 inline 元素中的一种。如果出现了混合内容，则应创建匿名的 block 呈现器，以包裹 inline 元素。

有一些呈现对象对应于 DOM 节点，但在树中所在的位置与 DOM 节点不同。浮动定位和绝对定位的元素就是这样，它们处于正常的流程之外，放置在树中的其他地方，并映射到真正的框架，而放在原位的是占位框架。

<div style="text-align:center;margin-top:20px" align="center">
  <img style="height:200px;" src="../images/browser-renderTree.png" />
</div>

### 布局
呈现器在创建完成并添加到呈现树时，并不包含位置和大小信息。计算这些值的过程称为`布局`或`重排`。

HTML采用基于流的布局模型，这意味着大多数情况下只要一次遍历就能计算出几何信息。处于流中靠后位置元素通常不会影响靠前位置元素的几何特征，因此布局可以按从左至右、从上至下的顺序遍历文档。但是也有例外情况，比如 HTML 表格的计算就需要不止一次的遍历 (3.5)。

坐标系是相对于根框架而建立的，使用的是`上坐标和左坐标`。

布局是一个递归的过程。它从根呈现器（对应于 HTML 文档的 <html> 元素）开始，然后递归遍历部分或所有的框架层次结构，为每一个需要计算的呈现器计算几何信息。

根呈现器的位置左边是 0,0，其尺寸为视口（也就是浏览器窗口的可见区域）。
所有的呈现器都有一个“layout”或者“reflow”方法，每一个呈现器都会调用其需要进行布局的子代的 layout 方法。

#### 全局布局和增量布局
全局布局是指触发了整个呈现树范围的布局，触发原因可能包括：

* 影响所有呈现器的全局样式更改，例如字体大小更改。
* 屏幕大小调整。
布局可以采用增量方式，也就是只对 dirty 呈现器进行布局（这样可能存在需要进行额外布局的弊端）。
当呈现器为 dirty 时，会异步触发增量布局。例如，当来自网络的额外内容添加到 DOM 树之后，新的呈现器附加到了呈现树中。

#### 异步布局和同步布局
增量布局是异步执行的。Firefox 将增量布局的“reflow 命令”加入队列，而调度程序会触发这些命令的批量执行。WebKit 也有用于执行增量布局的计时器：对呈现树进行遍历，并对 dirty 呈现器进行布局。
请求样式信息（例如“offsetHeight”）的脚本可同步触发增量布局。
全局布局往往是同步触发的。
有时，当初始布局完成之后，如果一些属性（如滚动位置）发生变化，布局就会作为回调而触发。

### 绘制
在绘制阶段，系统会遍历呈现树，并调用呈现器的“paint”方法，将呈现器的内容显示在屏幕上。绘制工作是使用用户界面基础组件完成的。
#### 全局绘制和增量绘制
和布局一样，绘制也分为全局（绘制整个呈现树）和增量两种。在增量绘制中，部分呈现器发生了更改，但是不会影响整个树。更改后的呈现器将其在屏幕上对应的矩形区域设为无效，这导致 OS 将其视为一块“dirty 区域”，并生成“paint”事件。OS 会很巧妙地将多个区域合并成一个。在 Chrome 浏览器中，情况要更复杂一些，因为 Chrome 浏览器的呈现器不在主进程上。Chrome 浏览器会在某种程度上模拟 OS 的行为。展示层会侦听这些事件，并将消息委托给呈现根节点。然后遍历呈现树，直到找到相关的呈现器，该呈现器会重新绘制自己（通常也包括其子代）。
#### 绘制顺序
CSS2 规范定义了绘制流程的顺序。绘制的顺序其实就是元素进入堆栈样式上下文的顺序。这些堆栈会从后往前绘制，因此这样的顺序会影响绘制。块呈现器的堆栈顺序如下：
* 背景颜色
* 背景图片
* 边框
* 子代
* 轮廓

#### Firefox 显示列表
Firefox 遍历整个呈现树，为绘制的矩形建立一个显示列表。列表中按照正确的绘制顺序（先是呈现器的背景，然后是边框等等）包含了与矩形相关的呈现器。这样等到重新绘制的时候，只需遍历一次呈现树，而不用多次遍历（绘制所有背景，然后绘制所有图片，再绘制所有边框等等）。
Firefox 对此过程进行了优化，也就是不添加隐藏的元素，例如被不透明元素完全遮挡住的元素。

#### WebKit 矩形存储
在重新绘制之前，WebKit 会将原来的矩形另存为一张位图，然后只绘制新旧矩形之间的差异部分。
**动态变化**     
在发生变化时，浏览器会尽可能做出最小的响应。因此，元素的颜色改变后，只会对该元素进行重绘。元素的位置改变后，只会对该元素及其子元素（可能还有同级元素）进行布局和重绘。添加 DOM 节点后，会对该节点进行布局和重绘。一些重大变化（例如增大“html”元素的字体）会导致缓存无效，使得整个呈现树都会进行重新布局和绘制。
