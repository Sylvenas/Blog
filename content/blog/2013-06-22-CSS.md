---
title:  "CSS基础知识"
author: [sylvenas]
categories: 'CSS'
img: './img/2013-06-12.jpeg'
---
### CSS使用方法

* link 标记
link必须放在head元素中，绝不能放在其他元素内部,因为link标记用来链接外部的样式，所以也被成为外部样式表
``` html
<link rel = 'stylesheet' type = 'text/css' href = 'main.css'/>
```
* style 元素
可以使用style元素包含样式表，它在文档中单独出现，因为这个样式表嵌套在文档中，所以也被成为文档样式表或者嵌套样式表
``` html
<style>
    p{
        color:#000;
    }
</style>
```
* @import
与link类似，`@import` 用于指示Web浏览器家在一个外部样式表，并在表现HTML文档时使用其样式，唯一的区别在于命令的具体语法和位置。

可以看到，`@import`出现在style容器中，它必须放在这里，也就是要放在其他CSS规则之前，否则将根本不起作用，考虑下面的例子：
``` html
    <style>
        p{
            color:#000;
        }
        @import url('...')
    </style>
```
这里外部引入的css将不会有任何作用，因为放在了其他的规则之前

* 内联样式
如果你只是想为单个元素设定一些样式，而不需要嵌套或者外部样式表，就可以使用HTML的`style`属性来设置一个内联样式(inline style),例如
``` html
<p style="color:red">hello world</p>
```
style属性可以应用在body内部出现的任何HTML元素上

### CSS选择器
* 通配选择器： * 选择全部的元素
* 元素选择器： div span
* 类选择器和ID选择器：   #，id
* 多类选择器： .class1.class2 选择同时包含两种类的元素
* 属性选择器：
    * h1[class]{color:#000}  选择包含class属性的h1
    * h1[title]{color:#000} 选择包含title属性的h1
    * 多属性选择器： a[href][title]{color:#fff} 同时包含href和title属性的a
    * = 具体属性值选择器：a[href='http://www.baidu.com']{color:###} 选择href属性值等于'http://www.baidu.com'的元素，即：选择具体属性值的元素
    * ～= 部分属性值选择器：img[title~='hello']{…} 选择所有title属性中有hello字符串的img,并且要求hello字符串两边都是空格，即：属性值部分包含就可以,但是要求该值两边都是空格
    * |= 部分属性选择器：img[title |= 'hello']{…} 选择所有title属性值是以'hello’或者’hello-' 为开头的img,即：属性值必须以某个字符串或者字符串+'-'开头,典型的应用场景是匹配语言简写代码，如'zh-CN','zh-TW'
    * ^=  部分属性选择器：img[title ^= 'hello']{…} 选择所有title属性值是以hello为开头的img,即：属性值必须以某个字符串开头
    * $=  部分属性选择器：img[title $= 'hello']{…} 选择所有title属性值是以hello为结尾的img,即：属性值必须以某个字符串结尾
    * *=   部分属性选择器：img[title *= 'hello']{…} 选择所有title属性值中包含hello字符串的的img, 即：属性值包含某个字符串就可以了,不要求是空格或者其他
* 父子选择器
    * 祖先与后代：div p{...} 选择div内部的看所有的p元素，不论嵌套多少层
    * 父与子：div>p{...} 选择div元素内直接嵌套的p元素，要求是直接嵌套
    * 相邻兄弟：div+p{...} 选择紧跟在div元素后面的p元素，要求必须是紧接着并且拥有同一个父元素，中间不能有其他元素，例如家里的老大和老二，老三和老四，老大和老三则不行
    * 通用兄弟：div~p{...} 选择div元素后面的p元素，要求他们拥有同一个父元素，但是不要求div和p是紧挨着的，例如:老大和老二，老大和老四，都是可以的
* 伪类
    伪类可以为某些元素的状态指定特定的样式，换句话说会根据另外某种条件而非文档结构向文档中的某些元素应用样式

    **静态伪类**：一般除了第一次显示之后，不会再次改变文档的样式
    * :link 用来选中尚未访问的超链接，包括那些已经给定了其他伪类选择器的链接，为了正确渲染链接元素的样式，:link伪类选择器一般应该放在其他选择器的前面
    * :visited 用来选择已经访问过的超链接
    * :first-child 选取属于其父元素的首个子元素的指定选择器,而绝非字面意思上的，该元素下的第一个元素
    **动态伪类**：可以根据用户的行为改变文档的外观
    * :hover 鼠标停留在某个元素上的时候，该元素`:hover`伪类中的样式就会应用到该元素上
    * :focus 指示当前拥有输入焦点的元素，一般为`input`,`select`之类的元素，拥有了输入焦点
    * :active 被用户激活的元素，例如:当鼠标指针停留在一个超链接上，如果用户点击了鼠标，就是激活了这个超链接

> 对于伪类，可以注意"link-visited-focus-hover-active"的顺序

* 伪元素
伪元素能够在文档中插入假象的元素，从而得到某种效果，常用的伪元素为:
* :first-letter 会选中某元素第一行的第一个字母，并且文字所处的行之前没有其他内容
* :first-line 会应用到某个块级元素的第一行，第一行的长度取决于很多因素，包括元素宽度，文本的文字的大小，:first-line 伪元素只能在块容器中,所以,:first-line伪元素只能在一个display值为`block`, `inline-block`, `table-cell` 或者 `table-caption`中有用。在其他的类型中，:first-line 是不起作用的。
* :before 可以用来在某个元素之前插入指定的内容，并且可以用content，设置插入的内容和内容的样式
* :after 可以用来在某个元素之后插入指定的内容，同before

### 结构和层叠
`继承`是指从一个元素向其后代元素传递属性值所采用的机制，而每一个合法的文档都会生成一个结构树，了解这一点，就能根据元素的祖先、属性、兄弟元素等等创建选择器来选择元素，有了这个结构树，选择器才能够起作用，这就是`继承`的核心所在。

在确定要想要为元素应用那些值的时候，用户代理不仅要考虑继承，还要考虑声明的特殊性，另外需要考虑声明的来源，而这个过程就叫做`层叠`。

这也是CSS的三个核心内容：`特殊性`，`继承`，`层叠`

#### 特殊性
应用到同一个元素上的多个CSS规则，浏览器会计算选择器的特殊性，并将这个特殊性附加到规则中的各个声明，如果一个元素有两个或者多个冲突的属性声明，那么最高特殊性的声明就会胜出。

选择器的特殊性由选择器本身的组件确定。特殊性值表述为4个部分，如：0，0，0，0。

一个选择器的具体啊特殊性如下确定：
* 对于选择器中给定的各个id属性值，加0，1，0，0
* 对于选择器中给定的各个类属性值、属性选择或者伪类，加0，0，1，0
* 对于选择器中给定的各个元素和伪元素加0，0，0，1
* 结合符和统配选择器对特殊性没有任何贡献，为0，0，0，0
* HTML内联样式的特殊性为1，0，0，0

>0,0,0,0的特殊性相比与没有任何特殊性还是有所区别的，而且很容易让人混淆，在后面的继承一节中会具体说明

#### 重要性
有时候某个声明可能非常重要，超越了所有其他声明，这个时候就是`!important`发挥的时候了，可以在CSS属性声明的结束分号之前插入`!important`来标志。例如：
``` css
    p.dark{ color:#333 !important;background:#fff;}
```
`!important`声明必须放在声明的最后，即分号前面。如果一个属性的值包含多个关键词，例如：font,则必须将`!important`放在所有font属性值的最后，否则整个声明都是无效的。

标志为`!important`的声明没有特殊的特殊性，不过要与非重要声明分开考虑。也就是说所有的`!important`声明会分为一组，而所有的非重要性声明分为一组，各自在小组内部使用特殊性来判断。但是如果一个重要声明和一个非重要声明发生冲突的话，那么毫无疑问，胜出的都是重要声明。

#### 继承
基于继承机制，样式不仅可以应用到指定的元素，还会应用到它的后代元素，例如向一个div元素应用一个颜色，那么这个颜色将会应用到div中的所有文本，甚至还会应用到div中的h1,p等等子元素。

继承的值会沿着树向下传播到后代元素，并且一直继续，直到没有更多的后代元素继承这个值为止。但是值绝对不会向上传播，也就是说不会把属性应用到父元素上去，这个是显而易见的。

>在HTLML中，不能向上传播的规则有一个例外：应用到body元素的背景样式可以传递到html元素，也就是文档的根元素

继承是CSS中最基础最常见的内容，除非有必要的理由，否则一般不会特殊考虑，正所谓`熟视无睹`,不过有几点需要说明。
* 不是所有的属性都可以继承。一般的，大多数的框模型(包括外边距，边框，内边距，背景)等属性都不能继承
* 继承的属性没有任何特殊性，这完全区别与`*`的0特殊性，看个例子：
``` html
    <style>
        * {
        color: gray
        }

        h1 {
        color: red;
        }
    </style>
    <h1>hello
        <em>world</em>
    </h1>
```
因为通配选择器适用于所有的元素，而且特殊性为0，那么很明显其颜色声明的`gray`要优先于没有任何特殊性继承而来的`black`,所以`em`会显示为灰色而不是黑色。

#### 层叠
如果玉带特殊性相等的两个规则同时应用到同给一个元素会怎么样呢？浏览器究竟会作出什么选择呢？举个例子：
``` css
    h1{ color : red;}
    h1{ color : blue;}
```
哪一个会占上风呢，这两个规则的特殊性都是`0,0,0,1`所以他们的权重相等，都应该应用的元素，但是同一个元素不可能既是红色的又是蓝色的，但是到底应用哪一个规则呢，这个时候需要引出CSS中`层叠`的概念。

我们先来看一下层叠的规则：
* 按显式权重对应用到该元素的所有声明排序。标志`!important`规则的权重要高于没有`!important`标志的规则。
* 按照特殊性对应用到给定元素的所有声明进行排序。有较高特殊性的规则权重大于有较低特殊性的元素。
* 按照出现顺序对应用到给定元素的所有声明排序。一个声明在样式表中或者文档中出现的越靠后，那么它的权重越大。如果样式表中有导入的样式，那么导入的样式权重低于文档中的样式。因为`@import`都是在`<style></style>`标签的最前面

#### 关于按照顺序进行排序有一个常见的误区
看例子代码：
``` html
<style>
    .h1 {
        color: red;
    }

    .h1-oth {
        color: blue;
    }
</style>
<h1 class='h1 h1-oth'>hello1</h1>
<h1 class='h1-oth h1'>hello2</h1>
```
实际上，上面的两个`hello`都是显示的蓝色(blue),而绝不会是第一个显示蓝色，第二个显示红色，在层叠的时候是按照属性在样式表或者文档中的先后顺序进行排序的，而绝不是按照在HTML元素`class`属性中出现的顺序惊醒排序的。

#### link,visited,hover,active
由于正是按照前后顺序排序的，所以超链接才会按照link,visited,hover,active的顺序进行，如下所示：
``` css
    a:link {
      color: blue
    }

    a:visited {
      color: purple
    }

    a:hover {
      color: red
    }

    a:active {
      color: orange
    }
```
上面四个选择器的特殊性都是0，0，1，0。他们有相同的权重，来源和特殊性，所以与元素匹配的最后一个选择器才会胜出。

如果不使用这个规则的话，例如按照首字母顺序排序`active-hover-link-visited`,那么任何时候都不会显示`:hover`或者`:active`的样式，因为所有的超链接，要么是没有访问的，要么是已经访问的！

### 值和单位


#### 浏览器前缀
最常见的浏览器前缀例如：Firefox的`-moz-`,IE的`-ms-`,Opera的`-o-`,Safari和Chrome的`-webkit-`。

浏览器前缀的原本目的是浏览器厂商为了实验一部分的新功能，而特殊添加的，网页开发者可以自由的尝试这些加了前缀的特性，并把试用结果反馈给工作组，而工作组随后会将这些反馈吸收到规范中，并逐渐完善该项特性的设计，最终演化为一个标准版本。

然而，理想很美好，现实很残酷！

当开发者发现这些实验性的、加了前缀的属性可以轻而易举地 实现以前大费周章才能达到的效果时，他们就开始滥用了。这些加了浏览器 前缀的属性迅速成为 CSS 领域的一大潮流。网上的教程会写到它们，Stack Overflow 上的问答会提到它们......很快，几乎每个有上进心的 CSS 开发者 都开始争先恐后地使用它们。

由于网页开发者使用无前缀的属性是想确保代码的向前兼容，那么工作组想要修改这些无前缀语法就变得不可能了。我们基本上就跟这些半生不熟的早期规范绑在一起了，只能通过极其有限的途径来修改它们。用不了多久，这个“坑”里的每个人就会意识到，**浏览器前缀已是一场史诗般的失败**。

最近，浏览器厂商已经很少以前缀的方式来实验性地实现新特性了。取而代之的是，这些实验性特性需要通过配置开关来启用，这可以有效防止开发者在生产环境中使用它们，因为你不能要求用户为了正确地浏览你的网站而去修改浏览器设置。当然，这会导致一个后果:尝试这些实验性特性的开发者会减少;但我们仍然会得到足够多的反馈，甚至是更高质量的反馈，同时还避免了浏览器前缀的所有缺点。不过我们还需要很长 的时间，才能从浏览器前缀所引发的涟漪效应中解脱出来。
